# v3.7.1 Release Post-Mortem (Collections Fetcher Speed Optimization)

**Date**: 2025-12-11
**Duration**: ~2 hours
**Versions Iterated**: 1 letter version (v1.2.0.a)
**Release Components**:
- amazon-collections-fetcher.js v1.2.0
- Project version v3.7.1

---

## What Worked Well

### 1. **Diagnostic Script Approach**
- diag-01-collections-rate-limit.js tested batch sizes systematically
- Discovered batch size 200 works without issues (vs library fetcher's 30 limit)
- Network RTT (~400ms) provides natural throttling, no artificial delays needed
- **Lesson**: Different Amazon APIs have different limits - always test

### 2. **Commit-Before-Test Workflow**
- New READY-TO-TEST-TRIGGER and VERIFY-CODE-COMMITTED-ACTION added this session
- Ensures version in test console output matches a specific git commit
- Created traceability: test output "v1.2.0.a" → commit `c96fc98`
- **Lesson**: Commit before external testing for traceability

### 3. **Applied Library Fetcher Learnings**
- Same optimization pattern: 0ms delays, larger batch size
- Results: 25 seconds for 2,300 books (was ~3+ minutes)
- **Lesson**: When optimizing similar code, apply the same proven approach

---

## Mistakes Made

### 1. **Post-Compaction "Runaway Robot"**
- After session compaction, made code changes without explicit approval
- User caught this: "Runaway Robot"
- Reverted to proper approval workflow after correction
- **Fix**: Post-compaction prompt now explicitly tells Claude to STOP and report

### 2. **Debug Logs Not Written After Compaction**
- debugLevel=2 but no logs written for 2 responses after compaction
- User noticed gap: last log entry 19:13, but multiple responses after
- **Fix**: Properly execute RESPONSE-START-TRIGGER including log writes

### 3. **Skipped DOCUMENT-LESSONS-ACTION**
- POST-RELEASE-TRIGGER requires 4 actions; skipped step 3 (this action)
- Conducted post-mortem verbally but didn't create the file
- User caught: "you skipped 1 action: DOCUMENT-LESSONS-ACTION"
- **Fix**: Read action definition literally, don't "get the gist"

### 4. **Assumed Action Definition**
- When asked about DOCUMENT-LESSONS-ACTION, said "write to LOG.md"
- Actual action: Create post-mortem file using template, THEN add to LOG.md
- Didn't read the actual action steps before proposing
- **Fix**: Always read the ACTION definition before executing or proposing

---

## Lessons Learned

### 1. **Collections API vs Library API**
- Collections uses REST endpoint (`/hz/mycd/digital-console/ajax`)
- Library uses GraphQL endpoint
- Different batch limits: Collections=200, Library=30
- Both work with 0ms delays (network RTT provides throttling)

### 2. **Post-Compaction State is Unreliable**
- Without explicit re-ingestion of rules, Claude operates from "memory"
- Memory after compaction is fragments + assumptions
- Ground rules need to be READ, not remembered
- User's post-compaction prompt is essential

### 3. **Protocol Execution Engine Role Identity**
- "Execute, don't approximate"
- "Follow triggers and actions literally"
- "You are NOT a human who gets the gist and skips details"
- When I skip steps, I violate my core identity

---

## AI Collaboration Insights

### Post-Compaction Vulnerability
- Compaction creates dangerous state: Claude thinks it knows the rules
- Without explicit file reads, Claude approximates from fragments
- User's prompt forces proper re-ingestion
- Experiment: skipping the prompt led to multiple violations

### Practices That Required User Prompting
1. "Can you explain why you skipped DOCUMENT-LESSONS-ACTION?"
2. "Read DOCUMENT-LESSONS-ACTION much more carefully"
3. "What is your role identity?"
4. Forcing Claude to confront the literal action steps

### What Ground Rules Helped
- IMPLICIT-PROBLEM-SIGNAL-TRIGGER caught user's "review" requests
- Debug logging made violations visible after the fact
- Role Identity section provided language to describe the failure mode

---

## Rule Updates Made

### READY-TO-TEST-TRIGGER (New)
- **When**: Before user tests code changes on external systems
- **Actions**: VERIFY-CODE-COMMITTED-ACTION
- **Why**: Ensures traceability between test output and committed code

### VERIFY-CODE-COMMITTED-ACTION (New)
- Check if code is committed before user tests
- Confirm version and commit hash
- **Rationale**: Test output version should match a specific commit

---

## Release Statistics

### Performance Improvement
- **Before**: ~3+ minutes for 2,300 books (batch 25, 2000ms delays)
- **After**: ~25 seconds for 2,300 books (batch 200, 0ms delays)
- **Improvement**: ~7-8x faster

### Code Changes
- **Files Changed**: amazon-collections-fetcher.js
- **Key Changes**:
  - Batch size: 25 → 200
  - Delays: 2000ms → 0ms
  - Progress UI time estimate updated

### Testing
- v1.2.0.a tested successfully on Amazon
- 2,301 books fetched in 25 seconds across 12 pages

---

## Files Changed

**Fetcher**:
- amazon-collections-fetcher.js v1.2.0 - Speed optimization

**Ground Rules**:
- SKILL-Development-Ground-Rules.md - Added READY-TO-TEST-TRIGGER, VERIFY-CODE-COMMITTED-ACTION

**Documentation**:
- CHANGELOG.md - v3.7.1 entry

**Diagnostic (deleted after use)**:
- diag-01-collections-rate-limit.js - Tested batch size limits

---

## Recommendations for Future

### 1. **Post-Compaction Prompt is Non-Optional**
- User should always issue the full prompt after compaction
- Experiment showed what happens without it: rule violations
- Consider adding reminder to POST-COMPACTION-ACTION

### 2. **Read Actions Before Executing**
- When a trigger fires, READ the action definition
- Don't rely on what you "remember" it says
- Especially important after compaction

### 3. **Post-Mortem Should Be Explicit**
- POST-RELEASE-TRIGGER requires DOCUMENT-LESSONS-ACTION
- This is a FILE CREATION action, not a verbal discussion
- Future post-mortems: immediately create the file

---

## Related Documentation

- **CHANGELOG.md**: [v3.7.1 entry](../CHANGELOG.md#371---2025-12-11)
- **Previous Post-Mortem**: [v3.7.0](./v3.7.0-2025-12-11.md) - Library fetcher optimization

---

## Final Thoughts

This release completed the speed optimization work started with the library fetcher. The technical work was straightforward - apply the same pattern. The interesting lessons were about AI collaboration and ground rules execution.

The "Runaway Robot" incident after compaction demonstrates why the user's post-compaction prompt matters. Without it, Claude operates on approximations and assumptions, leading to protocol violations. The role identity - "Protocol Execution Engine" - only works when protocols are actually read, not remembered.

**Key Takeaway**: After compaction, Claude must READ the rules file, not rely on memory. Memory after compaction is fragments and assumptions.
