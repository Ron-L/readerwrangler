# Post-Mortem: v3.14.0 - Dividers as Drop Targets

**Date:** 2025-12-23
**Duration:** ~6 hours (spanning two sessions with context compaction)
**Versions:** v3.14.0.a through v3.14.0.z (26 iterations!)

## Summary

What started as a "3-4 hour" task to make dividers valid drop targets turned into a complete drag-drop system overhaul. The feature itself was simple, but exposed deep performance problems that required architectural changes to solve.

## The Journey

### Phase 1: "Just Add Divider Drop Targets" (v3.14.0.a - v3.14.0.o)

**Initial approach:** Add drop indicator rendering to dividers, similar to books.

**What happened:** A cascade of edge cases:
- `.a-.c`: Double indicators (divider + adjacent book both claiming same position)
- `.d-.g`: Indicator positioning drift (state lag, cursor vs ghost position)
- `.h-.i`: Debug logging to understand the problem
- `.j-.l`: Visual confusion (ghost border looked like indicator)
- `.m-.o`: Conditional rendering bugs (book indicators on dividers, divider indicators on books)

**Lesson:** The per-component indicator approach was fundamentally flawed. Each of 2338 books had to check "am I the drop target?" - too many edge cases and no clean way to handle positions without elements.

### Phase 2: "Let's Fix It Properly" (v3.14.0.p - v3.14.0.r)

**Insight:** The real problem was O(N) hit detection - querying every element on every mouse move.

**Solution:** Row-Based Grid Index
- Build index once at drag start: O(N)
- Binary search on mouse move: O(log R) where R = rows
- Store row boundaries and item positions

**Result:** Hit detection went from sluggish to instant. But still laggy...

### Phase 3: "Why Is It Still Slow?" (v3.14.0.s - v3.14.0.u)

**Discovery 1:** Index was rebuilding 72 times during a single drag (on every auto-scroll tick).

**Fix:** Store `initialScrollTop` and calculate scroll delta on-the-fly instead of rebuilding.

**Result:** 3 index builds instead of 72. Better, but still laggy...

**Discovery 2:** The overlay indicator approach from `.s` was good, but `setDropTarget()` was still causing React re-renders across all 2338 book components.

### Phase 4: "Eliminate ALL Re-renders" (v3.14.0.v - v3.14.0.x)

**The breakthrough:** Move from React state to refs + direct DOM manipulation.

```javascript
// OLD: Every mouse move triggers React reconciliation
setDropTarget({ columnId, index });  // 2338 components re-render

// NEW: Direct DOM manipulation, zero React involvement
dropTargetRef.current = { columnId, index };
indicatorRef.current.style.top = '150px';  // Just move the element
```

**Changes:**
- `.v`: Remove old indicator code from book/divider components
- `.w`: `dropTarget` from state to ref, `updateIndicatorPosition()` via DOM
- `.x`: `dragCurrentPos` from state to ref, `updateGhostPosition()` via DOM

**Result:** "It no longer feels like a remote session" - user feedback after `.x`

### Phase 5: Cleanup (v3.14.0.y - v3.14.0.z)

- `.y`: Click empty grid area to clear selection (UX polish)
- `.z`: Remove timing/debug instrumentation

## What Went Well

1. **Design document paid off** - `docs/design/DRAG-DROP-DESIGN.md` captured the problem space and tracked solutions. When context compacted, the document preserved the architectural thinking.

2. **Incremental versions** - 26 small commits meant we could always roll back. Each version was testable.

3. **User feedback loop** - Real testing with 2338 books caught issues that smaller test sets would miss.

4. **Timing instrumentation** - Adding `performance.now()` measurements in `.s` proved the index was being rebuilt excessively. Data > guessing.

## What Went Wrong

1. **Underestimated complexity** - "3-4 hours" became 6+ hours. The feature was simple; the performance implications weren't.

2. **Chased symptoms before understanding root cause** - Versions `.a` through `.o` were mostly whack-a-mole on edge cases. Should have stepped back earlier to question the architecture.

3. **React's hidden costs** - Didn't anticipate that `setDropTarget()` would cause 2338 re-renders. React's reconciliation is usually "fast enough" - until it isn't.

4. **Context compaction risk** - Session compacted mid-feature. Lost some nuance, but design doc preserved key decisions.

## Key Technical Insights

### 1. React State vs Refs for High-Frequency Updates

**Rule of thumb:** If something updates on every mouse move (60+ times/second), use refs and direct DOM manipulation. React's reconciliation overhead is too high.

```javascript
// Bad for 60fps updates
const [position, setPosition] = useState({ x: 0, y: 0 });

// Good for 60fps updates
const positionRef = useRef({ x: 0, y: 0 });
const elementRef = useRef(null);
const updatePosition = (x, y) => {
    positionRef.current = { x, y };
    elementRef.current.style.transform = `translate(${x}px, ${y}px)`;
};
```

### 2. Spatial Indexing for Hit Detection

For large item counts, pre-compute spatial structure:
- Build index once (O(N))
- Query with binary search (O(log N))
- Update only when structure changes (scroll, resize)

### 3. Overlay vs Per-Component Rendering

When N components need to "know" about a single piece of state:
- **Don't:** Have each component check and conditionally render
- **Do:** Have ONE component that uses the state to position itself

### 4. Scroll Offset vs Index Rebuild

When scrolling changes positions:
- **Don't:** Rebuild entire index on every scroll event
- **Do:** Store initial scroll position, calculate delta at query time

## Metrics

| Metric | Before | After |
|--------|--------|-------|
| Hit detection | O(N) per move | O(log R) per move |
| Index builds per drag | 72+ | 3 |
| Components re-rendering | 2338 | 1 |
| User perception | "Laggy, like remote session" | "Smooth, native feel" |

## Future Considerations

1. **Virtual scrolling** - With 2338+ books, could benefit from only rendering visible items. Would require index adjustment.

2. **Touch support** - Current implementation is mouse-only. Touch events have different characteristics.

3. **Keyboard drag** - Accessibility consideration for non-mouse users.

## Files Changed

- `readerwrangler.js` - Main application (major changes to drag system)
- `readerwrangler.css` - Drop indicator styles
- `docs/design/DRAG-DROP-DESIGN.md` - New design document

## Conclusion

The feature request was "make dividers drop targets." The actual work was "rebuild the drag-drop system for large-scale performance."

This is a common pattern: simple features expose architectural limitations. The right response is to fix the architecture, not paper over it with increasingly complex conditionals.

26 versions later, we have a drag system that:
- Handles all drop target cases cleanly
- Performs well with 2000+ items
- Uses modern patterns (spatial indexing, direct DOM)
- Is documented for future maintenance

Worth the effort.
